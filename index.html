<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Airtel P2P Chess — SVG Pieces</title>
  <style>
    :root{
      --red:#e60000;
      --red-strong:#ff1a1a;
      --bg:#ffffff;
      --muted:#666;
      --board-light:#f0d9b5;
      --board-dark:#b58863;
      --card:#ffffff;
      --shadow: 0 8px 24px rgba(0,0,0,0.08);
      --radius:12px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      background:var(--bg);
      color:#111;
      display:flex;
      justify-content:center;
      padding:20px;
    }
    .app{
      width:min(1200px,98%);
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:18px;
      align-items:start;
    }
    @media (max-width:980px){ .app{ grid-template-columns:1fr } }

    .panel{ background:var(--card); border-radius:var(--radius); padding:14px; box-shadow:var(--shadow) }

    /* Clocks */
    .top-row{ display:flex; justify-content:space-between; gap:12px; margin-bottom:12px }
    .clock{ flex:1; background:var(--red); color:#fff; padding:10px 12px; border-radius:10px; text-align:center; font-weight:700; box-shadow:0 6px 18px rgba(0,0,0,0.06) }
    .clock.active{ background:var(--red-strong); transform:scale(1.03) }
    .clock .role{ font-size:12px; opacity:.95; font-weight:700 }
    .clock .time{ font-size:20px; margin-top:4px }

    .captured-line{ display:flex; gap:6px; min-height:34px; align-items:center; justify-content:center; margin:6px 0 }
    .cap-item{ width:28px; height:28px; display:inline-flex; align-items:center; justify-content:center; border-radius:6px; background:rgba(0,0,0,0.03) }

    .board-wrap{ display:flex; justify-content:center; align-items:center; }
    .board{
      width:100%;
      max-width:560px;
      aspect-ratio:1;
      display:grid;
      grid-template-columns:repeat(8,1fr);
      grid-template-rows:repeat(8,1fr);
      border-radius:10px;
      overflow:hidden;
      border:3px solid var(--red);
    }
    .square{ display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; transition:.08s }
    .square.light{ background:var(--board-light) }
    .square.dark{ background:var(--board-dark) }
    .sq-highlight{ box-shadow: inset 0 0 0 4px rgba(255,255,255,0.12) }
    .sq-move{ outline:4px solid rgba(10,132,255,0.22); outline-offset:-4px }
    .sq-capture{ outline:4px solid rgba(230,0,0,0.22); outline-offset:-4px }

    .controls{ display:flex; gap:8px; margin-top:12px }
    .btn{ background:var(--red); color:#fff; border:0; padding:8px 12px; border-radius:8px; font-weight:700; cursor:pointer }
    .btn.ghost{ background:#fff; color:var(--red); border:1px solid rgba(0,0,0,0.06) }

    /* Right side */
    .side{ display:grid; gap:12px }
    textarea,input{ width:100%; padding:8px; border-radius:8px; border:1px solid #e6e6e6; font-family:inherit }
    .history{ max-height:220px; overflow:auto; border:1px solid #f2f2f2; border-radius:8px; padding:8px; background:#fff }
    .history table{ width:100%; border-collapse:collapse; font-variant-numeric:tabular-nums }
    .history td, .history th{ padding:6px 8px; border-bottom:1px solid #fafafa; font-size:13px }
    .chat-box{ height:170px; overflow:auto; padding:8px; border:1px solid #f2f2f2; border-radius:8px; background:#fff }
    .chat-row{ margin-bottom:6px; font-size:14px }
    .muted{ color:var(--muted); font-size:13px }

    /* SVG pieces default size */
    .piece-svg { width:48px; height:48px; pointer-events:none; }
    .piece-small { width:26px; height:26px; }

  </style>
</head>
<body>
  <div class="app">

    <!-- Left: clocks, captured, board -->
    <div class="panel">
      <div class="top-row">
        <div id="whiteClock" class="clock">
          <div class="role">White</div>
          <div class="time" id="whiteTime">10:00</div>
        </div>

        <div id="blackClock" class="clock">
          <div class="role">Black</div>
          <div class="time" id="blackTime">10:00</div>
        </div>
      </div>

      <div id="whiteCaptured" class="captured-line" aria-hidden="false"></div>

      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="Chess board"></div>
      </div>

      <div id="blackCaptured" class="captured-line"></div>

      <div class="controls">
        <button id="flipBtn" class="btn ghost">Flip</button>
        <button id="undoBtn" class="btn ghost">Undo</button>
        <button id="newBtn" class="btn">New game</button>
        <button id="exportBtn" class="btn ghost">Export PGN</button>
      </div>
    </div>

    <!-- Right: signalling, history, chat -->
    <div class="side">
      <div class="panel">
        <div style="font-weight:700">P2P (copy/paste signaling)</div>
        <div class="muted">Create on one browser → copy Offer → paste in other → Accept → copy Answer back</div>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="createBtn" class="btn">Create Offer</button>
          <button id="joinBtn" class="btn ghost">Prepare to Join</button>
        </div>
        <textarea id="signalBox" placeholder="Offer / Answer (base64)" rows="4"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="acceptBtn" class="btn">Accept / Set</button>
          <button id="copyLocalBtn" class="btn ghost">Copy Local</button>
        </div>
      </div>

      <div class="panel history">
        <div style="font-weight:700">Move History</div>
        <table>
          <thead><tr><th>#</th><th>White</th><th>Black</th></tr></thead>
          <tbody id="historyBody"></tbody>
        </table>
      </div>

      <div class="panel">
        <div style="font-weight:700">Chat</div>
        <div id="chatBox" class="chat-box" aria-live="polite"></div>
        <div style="display:flex; gap:8px; margin-top:8px">
          <input id="chatInput" placeholder="Type a message and press Enter" />
          <button id="sendChatBtn" class="btn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Sounds -->
  <audio id="moveSound" preload="auto" src="https://cdn.jsdelivr.net/gh/naptha/tinyfiles/audio/chess-move.mp3"></audio>
  <audio id="captureSound" preload="auto" src="https://cdn.jsdelivr.net/gh/naptha/tinyfiles/audio/chess-capture.mp3"></audio>
  <audio id="gameOverSound" preload="auto" src="https://cdn.jsdelivr.net/gh/naptha/tinyfiles/audio/chess-gameover.mp3"></audio>

  <!-- chess.js (rules) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0-beta.6/chess.min.js"></script>

  <script>
  /* ----------------------
     Airtel P2P Chess (single file)
     - SVG piece graphics (inline SVG strings)
     - Chess.js for legal rules
     - WebRTC data channel for moves + chat (copy/paste signaling)
     - Clocks, captured strips, PGN export
     - localStorage persistence
     -----------------------*/

  // ---------- State ----------
  const CH = new Chess();
  let historyStack = [];
  let orientation = 'white';
  let selected = null;

  // clocks (seconds)
  let whiteSeconds = 10 * 60;
  let blackSeconds = 10 * 60;
  let activeColor = 'w';
  let clockTimer = null;

  // webRTC
  let pc = null;
  let dc = null;
  let isHost = false;

  // DOM refs
  const boardEl = document.getElementById('board');
  const whiteTimeEl = document.getElementById('whiteTime');
  const blackTimeEl = document.getElementById('blackTime');
  const whiteClockEl = document.getElementById('whiteClock');
  const blackClockEl = document.getElementById('blackClock');
  const whiteCapturedEl = document.getElementById('whiteCaptured');
  const blackCapturedEl = document.getElementById('blackCaptured');
  const historyBody = document.getElementById('historyBody');
  const signalBox = document.getElementById('signalBox');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');

  // sounds
  const sMove = document.getElementById('moveSound');
  const sCapture = document.getElementById('captureSound');
  const sOver = document.getElementById('gameOverSound');

  // captured arrays
  let whiteCaptured = []; // pieces white captured from black (shown near white)
  let blackCaptured = []; // pieces black captured from white

  // ---------- Inline SVG pieces (simple, elegant vectors)
  // Each function returns an encoded data URL for SVG; small and scalable.
  function svgDataURL(svgString){
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svgString);
  }

  // Base SVG template: piece color (fill), stroke color, and glyph path/text
  // For clarity I use stylized letter + ornament to represent pieces. These are crisp vectors.
  function pieceSVG(type, color, size = 48){
    const dark = (color === 'b');
    const bg = dark ? '#111' : '#ffffff';
    const fg = dark ? '#ffffff' : '#111';
    // Simple emblem: rounded shield + letter representing piece (K,Q,R,B,N,P)
    const letter = {
      p:'P', r:'R', n:'N', b:'B', q:'Q', k:'K'
    }[type.toLowerCase()] || '?';
    const svg = `
      <svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 64 64' aria-hidden='true'>
        <defs>
          <linearGradient id='g' x1='0' x2='1' y1='0' y2='1'>
            <stop offset='0' stop-color='${dark? "#333":"#fff"}' stop-opacity='1'/>
            <stop offset='1' stop-color='${dark? "#000":"#e6e6e6"}' stop-opacity='1'/>
          </linearGradient>
        </defs>
        <rect x='2' y='2' width='60' height='60' rx='10' fill='url(#g)' stroke='${dark? "#222":"#ddd"}' stroke-width='1.5'/>
        <g transform='translate(32,36)'>
          <text x='0' y='0' text-anchor='middle' font-family='-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial' font-size='26' font-weight='700' fill='${fg}'>${letter}</text>
        </g>
      </svg>
    `;
    return svgDataURL(svg);
  }

  // quick map for access: getDataURI('w','k') => 'data:...'
  function pieceDataURI(color, type){
    return pieceSVG(type, color);
  }

  // ---------- board rendering ----------
  // CH.board() returns array row0 = rank8.
  function drawBoard(){
    boardEl.innerHTML = '';
    const board = CH.board(); // 8x8
    const view = orientation === 'white' ? board : board.slice().reverse().map(r => r.slice().reverse());
    for(let r=0;r<8;r++){
      for(let c=0;c<8;c++){
        const squareIndexR = orientation === 'white' ? r : 7 - r;
        const squareIndexC = orientation === 'white' ? c : 7 - c;
        const sqName = indexToAlgebra(squareIndexR, squareIndexC);
        const el = document.createElement('div');
        const light = (r + c) % 2 === 0;
        el.className = 'square ' + (light ? 'light' : 'dark');
        el.dataset.square = sqName;
        const p = view[r][c];
        if(p){
          // create image element using inline SVG data URI
          const img = document.createElement('img');
          img.className = 'piece-svg';
          img.src = pieceDataURI(p.color, p.type);
          img.alt = (p.color === 'w' ? 'White':'Black') + ' ' + p.type.toUpperCase();
          el.appendChild(img);
        }
        el.addEventListener('click', onSquareClick);
        boardEl.appendChild(el);
      }
    }
    updateHighlights();
  }

  function indexToAlgebra(r,c){ return 'abcdefgh'[c] + (8 - r); }

  function updateHighlights(){
    boardEl.querySelectorAll('.square').forEach(s => s.classList.remove('sq-highlight','sq-move','sq-capture'));
    if(selected){
      const el = boardEl.querySelector(`[data-square="${selected}"]`);
      if(el) el.classList.add('sq-highlight');
      const moves = CH.moves({ square: selected, verbose:true });
      moves.forEach(m => {
        const toEl = boardEl.querySelector(`[data-square="${m.to}"]`);
        if(!toEl) return;
        if(m.captured) toEl.classList.add('sq-capture'); else toEl.classList.add('sq-move');
      });
    }
  }

  // ---------- events ----------
  function onSquareClick(e){
    const sq = e.currentTarget.dataset.square;
    // if no selection yet, ensure selecting own piece
    if(!selected){
      const p = CH.get(sq);
      if(!p || p.color !== CH.turn()) return;
      selected = sq;
      updateHighlights();
      return;
    }
    // try move
    const attempt = CH.move({ from: selected, to: sq, promotion: 'q' });
    selected = null;
    updateHighlights();
    if(attempt){
      onLocalMove(attempt);
    }
  }

  // ---------- move handlers ----------
  function onLocalMove(move){
    historyStack.push(CH.fen());
    if(move.captured){
      if(move.color === 'w') whiteCaptured.push(move.captured); else blackCaptured.push(move.captured);
      sCapture.play().catch(()=>{});
    } else sMove.play().catch(()=>{});
    activeColor = CH.turn();
    startClock();
    persistState();
    drawBoard();
    renderCaptured();
    renderHistory();
    broadcast({ type:'move', move: { from: move.from, to: move.to, promotion: move.promotion || null }});
    checkGameOver();
  }

  function onRemoteMove(m){
    const res = CH.move(m);
    if(!res){ console.warn('remote invalid move', m); return; }
    historyStack.push(CH.fen());
    if(res.captured){
      if(res.color === 'w') whiteCaptured.push(res.captured); else blackCaptured.push(res.captured);
      sCapture.play().catch(()=>{});
    } else sMove.play().catch(()=>{});
    activeColor = CH.turn();
    startClock();
    persistState();
    drawBoard();
    renderCaptured();
    renderHistory();
    checkGameOver();
  }

  function renderCaptured(){
    whiteCapturedEl.innerHTML = '';
    whiteCaptured.forEach(t => {
      const span = document.createElement('span'); span.className='cap-item';
      const img = document.createElement('img'); img.className='piece-small'; img.src = pieceDataURI('b', t);
      span.appendChild(img); whiteCapturedEl.appendChild(span);
    });
    blackCapturedEl.innerHTML = '';
    blackCaptured.forEach(t => {
      const span = document.createElement('span'); span.className='cap-item';
      const img = document.createElement('img'); img.className='piece-small'; img.src = pieceDataURI('w', t);
      span.appendChild(img); blackCapturedEl.appendChild(span);
    });
  }

  // ---------- clocks ----------
  function startClock(){
    stopClock();
    updateClockDisplay();
    clockTimer = setInterval(() => {
      if(activeColor === 'w') whiteSeconds--; else blackSeconds--;
      updateClockDisplay();
      if(whiteSeconds <= 0){ stopClock(); onTimeExpired('w'); }
      if(blackSeconds <= 0){ stopClock(); onTimeExpired('b'); }
    }, 1000);
  }
  function stopClock(){ if(clockTimer){ clearInterval(clockTimer); clockTimer = null; } }
  function onTimeExpired(color){
    const winner = color === 'w' ? 'Black' : 'White';
    sOver.play().catch(()=>{});
    alert(`Time out — ${winner} wins.`);
  }
  function updateClockDisplay(){
    whiteTimeEl.textContent = formatTime(whiteSeconds);
    blackTimeEl.textContent = formatTime(blackSeconds);
    whiteClockEl.classList.toggle('active', activeColor === 'w');
    blackClockEl.classList.toggle('active', activeColor === 'b');
  }
  function formatTime(sec){ if(sec<0) sec=0; const m=Math.floor(sec/60); const s=(sec%60).toString().padStart(2,'0'); return `${m}:${s}`; }

  // ---------- move history ----------
  function renderHistory(){
    historyBody.innerHTML = '';
    const moves = CH.history({ verbose:true });
    let row = null, num = 1;
    moves.forEach(m => {
      if(m.color === 'w'){
        row = document.createElement('tr');
        const no = document.createElement('td'); no.textContent = num++;
        const w = document.createElement('td'); w.textContent = m.san;
        const b = document.createElement('td'); b.textContent = '';
        row.appendChild(no); row.appendChild(w); row.appendChild(b);
        historyBody.appendChild(row);
      } else if(row){
        row.children[2].textContent = m.san;
      }
    });
    const h = document.querySelector('.history'); if(h) h.scrollTop = h.scrollHeight;
  }

  // ---------- game over ----------
  function checkGameOver(){
    if(CH.game_over()){
      let msg = 'Game over: ';
      if(CH.in_checkmate()) msg += 'Checkmate.';
      else if(CH.in_stalemate()) msg += 'Stalemate.';
      else if(CH.insufficient_material()) msg += 'Insufficient material.';
      else msg += 'Draw.';
      sOver.play().catch(()=>{});
      alert(msg);
    }
  }

  // ---------- persistence ----------
  function persistState(){
    const data = {
      fen: CH.fen(),
      whiteSeconds, blackSeconds, activeColor,
      orientation, whiteCaptured, blackCaptured,
      pgn: CH.pgn()
    };
    localStorage.setItem('p2p_chess_v2', JSON.stringify(data));
  }
  function loadPersisted(){
    try{
      const raw = localStorage.getItem('p2p_chess_v2'); if(!raw) return;
      const data = JSON.parse(raw);
      if(data.fen) CH.load(data.fen);
      if(typeof data.whiteSeconds === 'number') whiteSeconds = data.whiteSeconds;
      if(typeof data.blackSeconds === 'number') blackSeconds = data.blackSeconds;
      if(data.orientation) orientation = data.orientation;
      if(Array.isArray(data.whiteCaptured)) whiteCaptured = data.whiteCaptured;
      if(Array.isArray(data.blackCaptured)) blackCaptured = data.blackCaptured;
    }catch(e){ console.warn('load persisted fail', e); }
  }

  // ---------- PGN export ----------
  function exportPGN(){ const p = CH.pgn(); const blob = new Blob([p], {type:'text/plain'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='game.pgn'; a.click(); }

  // ---------- WebRTC (copy/paste signalling) ----------
  function createPeer(asHost){
    pc = new RTCPeerConnection({ iceServers:[{ urls:'stun:stun.l.google.com:19302' }] });
    pc.onicecandidate = () => { /* we rely on full SDP copy-paste; no trickle implemented */ };
    pc.ondatachannel = (e) => { dc = e.channel; bindDC(); };
    if(asHost){ dc = pc.createDataChannel('p2p-chess'); bindDC(); }
    return pc;
  }

  function bindDC(){
    if(!dc) return;
    dc.onopen = ()=> addChatSystem('[connected]');
    dc.onclose = ()=> addChatSystem('[disconnected]');
    dc.onmessage = (ev) => {
      try{
        const data = JSON.parse(ev.data);
        if(data.type === 'move') onRemoteMove(data.move);
        else if(data.type === 'chat') addChat(`Opponent: ${data.message}`);
        else if(data.type === 'sync' && data.pgn){ CH.load_pgn(data.pgn); drawBoard(); renderHistory(); renderCaptured(); persistState(); }
      }catch(e){ console.warn('invalid data', e); }
    };
  }

  async function createOffer(){
    isHost = true;
    createPeer(true);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    signalBox.value = btoa(JSON.stringify(pc.localDescription));
    addChatSystem('[Offer created — copy & send to peer]');
  }

  async function prepareJoin(){
    isHost = false;
    createPeer(false);
    addChatSystem('[Ready to accept Offer — paste offer and press Accept]');
  }

  async function acceptSignal(){
    try{
      const raw = signalBox.value.trim(); if(!raw) return addChatSystem('[no signal]');
      const obj = JSON.parse(atob(raw));
      if(obj.type === 'offer'){
        if(!pc) createPeer(false);
        await pc.setRemoteDescription(obj);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        signalBox.value = btoa(JSON.stringify(pc.localDescription));
        addChatSystem('[Answer created — copy & send back to host]');
      } else if(obj.type === 'answer'){
        if(!pc) return addChatSystem('[no host peer]');
        await pc.setRemoteDescription(obj);
        addChatSystem('[Answer set — connecting...]');
      } else addChatSystem('[unsupported signal]');
    }catch(e){ console.error(e); addChatSystem('[invalid signal data]'); }
  }

  function broadcast(obj){
    if(dc && dc.readyState === 'open') dc.send(JSON.stringify(obj));
  }

  // ---------- chat helpers ----------
  function addChat(txt){
    const d = document.createElement('div'); d.className='chat-row'; d.textContent = txt; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight;
  }
  function addChatSystem(txt){
    const d = document.createElement('div'); d.className='chat-row muted'; d.textContent = txt; chatBox.appendChild(d); chatBox.scrollTop = chatBox.scrollHeight;
  }

  // ---------- wiring ----------
  document.getElementById('flipBtn').addEventListener('click', ()=>{ orientation = (orientation==='white' ? 'black' : 'white'); persistState(); drawBoard(); });
  document.getElementById('undoBtn').addEventListener('click', ()=>{ if(historyStack.length){ CH.load(historyStack.pop()); drawBoard(); renderHistory(); persistState(); }});
  document.getElementById('newBtn').addEventListener('click', ()=>{ CH.reset(); historyStack=[]; whiteCaptured=[]; blackCaptured=[]; whiteSeconds=10*60; blackSeconds=10*60; activeColor='w'; persistState(); drawBoard(); renderCaptured(); renderHistory(); startClock(); });
  document.getElementById('exportBtn').addEventListener('click', exportPGN);

  document.getElementById('createBtn').addEventListener('click', createOffer);
  document.getElementById('joinBtn').addEventListener('click', prepareJoin);
  document.getElementById('acceptBtn').addEventListener('click', acceptSignal);
  document.getElementById('copyLocalBtn').addEventListener('click', ()=>{ navigator.clipboard?.writeText(signalBox.value).then(()=>addChatSystem('[Copied local SDP to clipboard]')).catch(()=>{}); });

  document.getElementById('sendChatBtn').addEventListener('click', ()=>{ const v = chatInput.value.trim(); if(!v) return; addChat('You: ' + v); broadcast({ type:'chat', message: v }); chatInput.value=''; });
  chatInput.addEventListener('keypress', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); document.getElementById('sendChatBtn').click(); }});

  // ---------- init ----------
  function init(){
    loadPersisted();
    drawBoard();
    renderCaptured();
    renderHistory();
    updateClockDisplay();
    startClock();
    addChatSystem('[Ready]');
  }

  init();

  </script>
</body>
</html>
