<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Modern P2P Chess</title>
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #f0f0f5, #e6e9f0);
      display: flex;
      height: 100vh;
      align-items: center;
      justify-content: center;
    }
    .app {
      backdrop-filter: blur(12px) saturate(180%);
      -webkit-backdrop-filter: blur(12px) saturate(180%);
      background: rgba(255, 255, 255, 0.65);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: flex;
      padding: 20px;
      gap: 20px;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 64px);
      grid-template-rows: repeat(8, 64px);
      border: 2px solid #999;
      border-radius: 10px;
      overflow: hidden;
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 36px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .light { background: #f0d9b5; }
    .dark { background: #b58863; }
    .highlight { background: #f6f669 !important; }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    textarea, input, button {
      font-family: inherit;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
      padding: 8px;
    }
    textarea { resize: vertical; min-height: 60px; }
    .chat-box {
      display: flex;
      flex-direction: column;
      height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 8px;
      background: #fff;
    }
    .chat-input {
      display: flex;
      gap: 5px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div>
      <div class="board" id="board"></div>
      <div style="margin-top:10px">
        <button id="flipBtn">Flip Board</button>
        <button id="undoBtn">Undo</button>
        <button id="exportPGN">Export PGN</button>
      </div>
    </div>
    <div class="controls">
      <button id="createGame">Create Game</button>
      <button id="joinGame">Join Game</button>
      <textarea id="signalData" placeholder="Paste/copy signal here"></textarea>
      <button id="acceptSignal">Accept</button>
      <div class="chat-box" id="chatBox"></div>
      <div class="chat-input">
        <input type="text" id="chatInput" placeholder="Type message...">
        <button id="sendChat">Send</button>
      </div>
    </div>
  </div><audio id="moveSound" src="https://freesound.org/data/previews/320/320654_5260877-lq.mp3"></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0-beta.6/chess.min.js"></script>  <script>
    const boardEl = document.getElementById('board');
    const chess = new Chess();
    let selectedSquare = null;
    let orientation = 'white';
    let historyStack = [];

    function renderBoard() {
      boardEl.innerHTML = '';
      const board = chess.board();
      const ranks = orientation === 'white' ? board : board.slice().reverse();
      ranks.forEach((row, rIndex) => {
        const cols = orientation === 'white' ? row : row.slice().reverse();
        cols.forEach((square, cIndex) => {
          const div = document.createElement('div');
          div.className = 'square ' + (((rIndex + cIndex) % 2 === 0) ? 'light' : 'dark');
          div.dataset.rank = orientation === 'white' ? 7 - rIndex : rIndex;
          div.dataset.file = orientation === 'white' ? cIndex : 7 - cIndex;
          if (square) {
            div.textContent = pieceToUnicode(square);
          }
          boardEl.appendChild(div);
        });
      });
      saveGame();
    }

    function pieceToUnicode(piece) {
      const map = {
        p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚',
        P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔'
      };
      return map[piece.color === 'w' ? piece.type.toUpperCase() : piece.type];
    }

    boardEl.addEventListener('click', e => {
      if (!e.target.classList.contains('square')) return;
      const rank = parseInt(e.target.dataset.rank);
      const file = parseInt(e.target.dataset.file);
      const square = 'abcdefgh'[file] + (rank + 1);
      if (selectedSquare) {
        const move = chess.move({ from: selectedSquare, to: square, promotion: 'q' });
        if (move) {
          historyStack.push(move);
          playMoveSound();
          sendMove(move);
          renderBoard();
        }
        selectedSquare = null;
      } else {
        selectedSquare = square;
      }
    });

    document.getElementById('flipBtn').onclick = () => {
      orientation = orientation === 'white' ? 'black' : 'white';
      renderBoard();
    };

    document.getElementById('undoBtn').onclick = () => {
      chess.undo();
      renderBoard();
    };

    document.getElementById('exportPGN').onclick = () => {
      const blob = new Blob([chess.pgn()], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'game.pgn';
      a.click();
    };

    function playMoveSound() {
      document.getElementById('moveSound').play();
    }

    function saveGame() {
      localStorage.setItem('chessGame', JSON.stringify({ fen: chess.fen(), history: chess.history() }));
    }

    function loadGame() {
      const saved = localStorage.getItem('chessGame');
      if (saved) {
        const state = JSON.parse(saved);
        chess.reset();
        state.history.forEach(m => chess.move(m));
      }
    }

    loadGame();
    renderBoard();

    // --- P2P WebRTC ---
    let pc, channel;

    function initConnection() {
      pc = new RTCPeerConnection();
      channel = pc.createDataChannel('chess');
      channel.onmessage = handleMessage;
      pc.ondatachannel = e => { channel = e.channel; channel.onmessage = handleMessage; };
    }

    function handleMessage(e) {
      const data = JSON.parse(e.data);
      if (data.type === 'move') {
        chess.move(data.move);
        playMoveSound();
        renderBoard();
      } else if (data.type === 'chat') {
        addChat('Opponent: ' + data.message);
      }
    }

    function sendMove(move) {
      if (channel && channel.readyState === 'open') {
        channel.send(JSON.stringify({ type:'move', move }));
      }
    }

    function sendChatMsg(msg) {
      if (channel && channel.readyState === 'open') {
        channel.send(JSON.stringify({ type:'chat', message: msg }));
      }
    }

    document.getElementById('sendChat').onclick = () => {
      const input = document.getElementById('chatInput');
      const msg = input.value;
      if (msg.trim()) {
        addChat('You: ' + msg);
        sendChatMsg(msg);
        input.value = '';
      }
    };

    function addChat(text) {
      const chatBox = document.getElementById('chatBox');
      const div = document.createElement('div');
      div.textContent = text;
      chatBox.appendChild(div);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    document.getElementById('createGame').onclick = async () => {
      initConnection();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      document.getElementById('signalData').value = JSON.stringify(offer);
    };

    document.getElementById('acceptSignal').onclick = async () => {
      const data = JSON.parse(document.getElementById('signalData').value);
      if (data.type === 'offer') {
        initConnection();
        await pc.setRemoteDescription(data);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        document.getElementById('signalData').value = JSON.stringify(answer);
      } else if (data.type === 'answer') {
        await pc.setRemoteDescription(data);
      }
    };
  </script></body>
        </html>
